{"timestamp": 1745966772.854911, "stored_source_code": "# Processar horas\nimport numpy as np\nimport pandas as pd\nimport ast\n# declare a list tasks whose products you want to use as inputs\nupstream = None\nproduct = None\ndiscrete_hours = None # valida se as horas ser\u00e3o discretas ou cont\u00ednuas \ndf_input_path = '../../dados/X_trainToronto.csv'\ndef literal_eval(x):\n    if pd.isna(x):\n        return dict()\n    raw_dict = ast.literal_eval(x)\n    for key in raw_dict:\n        raw_dict[key] = ast.literal_eval(raw_dict[key])\n    return raw_dict\n        \ndef proccess_df(df):\n    df['hours'] = df['hours'].apply(lambda x: ast.literal_eval(x) if not pd.isna(x) else dict())\ndf_reg = pd.read_csv(df_input_path)\nproccess_df(df_reg)\ndf_reg = df_reg[['business_id', 'hours']]\ndf_reg\n## Tratamento das horas abertas\nfrom datetime import datetime, timedelta\n\nmidnight_tomorrow = datetime.strptime(\"0:0\", \"%H:%M\") + timedelta(days=1)\nmidnight_today = datetime.strptime(\"0:0\", \"%H:%M\")\ndaysOfWeek = {'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'}\ntimes_of_day = {\n         'morning': (datetime.strptime('6:0', \"%H:%M\"), datetime.strptime('12:0', \"%H:%M\")), \n         'afternoon': (datetime.strptime('12:0', \"%H:%M\"), datetime.strptime('18:0', \"%H:%M\")), \n         'evening': (datetime.strptime('18:0', \"%H:%M\"), midnight_tomorrow),\n         'night': (midnight_today, datetime.strptime('6:0', \"%H:%M\"))\n        }\n\ndef fill_hours(obj):\n    result = {}\n    for dayOfweek in daysOfWeek:\n        hour1 = datetime.strptime(\"0:0\", \"%H:%M\")\n        hour2 = datetime.strptime(\"0:0\", \"%H:%M\")\n        if dayOfweek in obj:\n            hours_obj = obj[dayOfweek].split('-')\n            hour1 = datetime.strptime(hours_obj[0], \"%H:%M\")\n            hour2 = datetime.strptime(hours_obj[1], \"%H:%M\")\n            if hour1 >= hour2:\n                hour2 += timedelta(days=1)\n        for key in times_of_day:\n            d1 = times_of_day[key][0]\n            d2 = times_of_day[key][1]\n            \n            value = calculate_hoursOfDay(hour1, hour2, d1, d2)\n            result[f'business_open_{dayOfweek}_{key}'] = value\n    return result\n            \n    \ndef calculate_hoursOfDay(hour1: datetime, hour2: datetime, d1: datetime, d2: datetime):\n    if hour1 > d2 or hour2 < d1:\n        if hour2.day == midnight_tomorrow.day and (hour1 != midnight_tomorrow and hour2 != midnight_tomorrow):\n            day1 = calculate_hoursOfDay(midnight_tomorrow, hour2, d1 + timedelta(days=1), d2 + timedelta(days=1))\n            day2 = calculate_hoursOfDay(hour1, midnight_tomorrow, d1, d2)\n            return day1 + day2\n        return 0.0\n        \n    inf = hour1\n    sup = hour2\n    if hour1 <= d1:\n        inf = d1\n    if hour2 >= d2:\n        sup = d2\n        \n    if discrete_hours == True and float((sup - inf).seconds) > 0.001:\n        return 1.0\n    return float((sup - inf).seconds) / 21600.0\nhours_features = pd.DataFrame(list(df_reg['hours'].apply(fill_hours)))\ndf_reg = pd.concat([df_reg, hours_features], axis=1)\ndf_reg\ndf_reg.to_parquet(product['data'])\n## Teste manual\nhours_columns = [x for x in df_reg.columns if x.startswith('business_open_')]\nfrom IPython.display import display\nwith pd.option_context('display.max_rows', 5, 'display.max_columns', None): \n    display(df_reg.iloc[13]['hours'])\n    display(df_reg[hours_columns].iloc[[13]])\n    display('----------------------------------')\n    display(df_reg.iloc[542]['hours'])\n    display(df_reg[hours_columns].iloc[[542]])\n    display('----------------------------------')\n    display(df_reg.iloc[5389]['hours'])\n    display(df_reg[hours_columns].iloc[[5389]])", "params": {"df_input_path": "../../dados/X_trainToronto.csv", "discrete_hours": false}}